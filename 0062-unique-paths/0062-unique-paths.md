# LeetCode 第 62 号问题：不同路径

### 题目描述

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

**示例 1:**

```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

### 题目解析

**动态规划4步解题法**

1. 确定状态（研究最优策略的最后一步，转化为子问题）
2. 转移方程（根据子问题定义直接得到）
3. 初始条件和边界情况（细心，考虑周全）
4. 计算顺序（利用之前的计算结果）

对该题目而言：

- 确定状态
  - 研究最优策略的最后一步，即到达终点时的路径总数。怎么转化为子问题呢？显然，往前看一步，要想到达重点，则首先要经过倒数第二步（左侧或上侧），即对倒数第二步来讲，有两种不同的选择可以到达重点
  - 状态`dp[i][j]`：到达当前位置（i,j）时，路径的数量。**

- 转移方程
  - 是问题与子问题之间的转移？
  - 因此，状态转移方程：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
  - 解释：到达状态(i, j)时，应该是由状态(i, j-1)与状态(i-1, j)共同转移而来的
- 初始条件和边界情况
  - 初始条件：图中最上面一行（即矩阵第一行）只有一种路径；最左侧一行（即矩阵第一列）只有一种路径。
  - 最后求解：是状态`dp[i][j]`的最右下角元素
- 计算顺序
  - 该题目而言：直接从左上角开始遍历即可。先算子问题再计算问题。
  - 不涉及复杂的顺序问题，顺序问题参考：leetcode[122]买卖股票的最佳时机：
  - 最后求解：是状态`dp[i][j]`的最右下角元素

### 代码实现

```python
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        mat = [[0 for _ in range(n)] for _ in range(m)] 
        for r in range(m):
            mat[r][0] = 1
        for c in range(n):
            mat[0][c] = 1
        for r in range(1,m):
            for c in range(1,n):
                mat[r][c] = mat[r-1][c] + mat[r][c-1]
        return mat[-1][-1]
```

