# LeetCode 第 122 号问题：买卖股票的最佳时机II

题目来源于 LeetCode 上第 122 号问题：买卖股票的最佳时机II。题目难度为 Easy


### 题目描述

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
```

解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
```

解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

### 题目解析

#### 方法一：暴力搜索

我是最后写搜索算法的，但是把它放在了开头，意思是想告诉自己：搜索算法应该是最先想到的。

可能暴力搜索不能让有些面试官满意，但是我觉得有些不拘一格面试官会认可你先说出搜索的算法这个思路，然后再以搜索算法为起点，考虑更好的算法。

根据题意：因为不限制交易次数，在每一天，我就可以根据当前是否持有股票选择相应的操作。“暴力搜索” 也叫 “回溯搜索”、“回溯法”，首先画出树形图。

<img src="https://pic.leetcode-cn.com/3ede46d543e0fcd2ec1b4f9031637fd404b4bdf73505bb1233d870ac92ea8283-image.png" alt="img" style="zoom:50%;" />

#### 方法二：贪心算法

这道题使用贪心算法的流程是这样的：做出局部最优选择来求取最优解

**从第 i 天（这里 i >= 1）开始，与第 i - 1 的股价进行比较，如果股价有上升（严格上升），就将升高的股价（ prices[i] - prices[i- 1] ）记入总利润，按照这种算法，得到的结果就是符合题意的最大利润。**

下面对这个算法进行几点说明：

1、该算法仅可以用于计算，但计算的过程并不是真正交易的过程，但可以用**贪心算法计算题目要求的最大利润**。下面说明这个等价性：以 `[1, 2, 3, 4]` 为例，这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：
$$
res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - price[0]) 
\\ = price[3]-price[0]
$$
仔细观察上面的式子，按照贪心算法，在索引为 1、2、3 的这三天，我们做的操作应该是买进昨天的，卖出今天的，虽然这种操作题目并不允许，但是它等价于：“在索引为 0 的那一天买入，在索引为 3 的那一天卖出”。

2、解释一下它为什么叫 “贪心算法”

我们还是回到贪心算法的定义：（下面是来自《算法导论（第三版）》第 16 章的叙述）

![img](https://pic.leetcode-cn.com/5de2bc50e56f42566522df6fe4dcf0eca7396db765f7a2ca2fe9f1fd9a647270.png)

**“贪心算法” 在每一步总是做出在当前看来最好的选择。**

因此，“贪心算法” 和 “动态规划”、“回溯搜索” 算法一样，完成一件事情，是分步决策的；“贪心算法” 在每一步总是做出在当前看来最好的选择，我是这样理解 “最好” 这两个字的意思：“最好” 的意思往往根据题目而来，可能是 “最小”，也可能是 “最大”；

贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），**因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的。**

**这道题 “贪心” 的地方在于，对于 “今天的股价 - 昨天的股价”，得到的结果有 3 种可能：（1）正数（2）0（3）负数。**

**贪心算法的决策是：只加正数。**

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if len(prices)<= 1:
            return 0
        res = 0
        for i in range(1, len(prices)):
            res = res + max(0, prices[i]-prices[i-1])
            
        return res
```
**复杂度分析：**

时间复杂度：$\mathcal O(N)$;     空间复杂度：$\mathcal O(1)$

下面证明 “贪心算法” 的有效性。

我们借助 “差分” 这个概念，可以证明 “贪心算法” 的有效性。**贪心算法就是选择那些所有差分（严格）大于 0 的数，把它们相加即可。**

使用反证法：假设 “贪心算法” 得到的解并不是最优解，即我们还能够找到一个可行解比 “贪心算法” 得到的利润还多。差分数组中除了差分为正数的项以外，还有就是差分为 0 的项与差分为负数的项。“贪心算法” 是所有差分为正数的项的和。

1、如果可行解在 “贪心算法” 的基础上，选择了差分为 0 的项，得到的结果与“贪心算法”得到的结果一样，因此加上差分为 0 的项不会比“贪心算法”得到的结果更好；

2、如果可行解在 “贪心算法” 的基础上，选择了差分为负数的项，加上一个负数得到的结果一定比 “贪心算法” 得到的结果要少，加上差分为负数的项，一定比 “贪心算法” 得到的结果更少；

3、如果可行解在 “贪心算法” 的基础上，去掉了任何一个差分为正数的项，同上，得到的结果一定比 “贪心算法” 得到的结果要小，因此，“贪心算法” 的所有组成项不能删去任何一个。

综上，除了 “贪心算法” 以外，找不到一个更优的解法，因此 “贪心算法” 就是最优解。（证完）

#### 方法三：动态规划

**想到动态规划的原因是：可以用贪心算法解决的问题，一般情况下都可以用动态规划。因此，不妨从 “状态”、“状态转移方程” 的角度考虑一下，使用动态规划的思路解决这道问题。**

根据 Leetcode第 121 题的思路，可以设置一个二维矩阵表示状态。

- **第 1 步：定义状态`dp[i][j]`**

  第一维`i`表示索引为` i`的那一天**（具有前缀性质，即考虑了之前天数的收益）能获得的最大利润**；

  第二维` j `表示索引为`i `的那一天是持有股票，还是持有现金。 **0 表示持有现金（cash），1 表示持有股票（stock）**。

- **第 2 步：思考状态转移方程**

  状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；

  因为不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；

  写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。

  **每一天状态可以转移，也可以不动**。状态转移用下图表示：

  ![img](https://pic.leetcode-cn.com/041a4d01398359409ecc69dacc13a44d179dd1a2a9f43b1def80e9a6acceee55-image.png)

  **第i天持有现金`<---` max( 第i-1天持有现金&有收益, 第i-1天持有股票&第i天卖出)：**
  $$
  dp[i][0]=\max(dp[i-1][0], dp[i-1][1]+price[i])
  $$
  **第i天持有股票`<---` max( 第i-1天持有现金&第i天买入股票, 第i-1天持有股票&有收益)：**
  $$
  dp[i][1]=\max(dp[i-1][1], dp[i-1][0]-price[i])
  $$
  解释：第i天可能由两个状态转移而来，①第i-1天持有现金cash；②第i-1天持有股票stock

  ![image-20200904165926508](C:\Users\BU\AppData\Roaming\Typora\typora-user-images\image-20200904165926508.png)

- **第 3 步：确定起始**

  如果第一天不买入，`dp[0][0]` = 0；

  如果第一天买入股票，当前收益则是负数，即 `dp[0][1]`= -prices[i]；

- **第 4 步：确定终止**

  终止的时候，输出 `dp[len - 1][0]`，因为一定有 `dp[len - 1][0]` > `dp[len - 1][1]`。

**复杂度分析：**

时间复杂度：$\mathcal O(N)$，这里 $N$ 表示股价数组的长度。

空间复杂度：$\mathcal O(N)$

我们也可以将状态数组分开设置，语义更明确，结合状态转移即可完成求解。

![image-20200904170640829](C:\Users\BU\AppData\Roaming\Typora\typora-user-images\image-20200904170640829.png)

定义cash数组：代表持有现金时的收益

* `cash[i] = max(cash[i-1], stock[i-1]+price[i]) `    cash  <---- cash（状态不变） + stock（状态更新）

定义stock数组：代表持有股票时的收益

* `stock[i] = max(stock[i-1], cash[i-1]-price[i])`

```python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        if len(prices)<= 1:
            return 0
        cash = [0]*len(prices)    # 持有现金时的收益
        stock = [-prices[0]]*len(prices)    # 持有股票的收益

        for i in range(1,len(prices)):

            cash[i] = max(cash[i-1], stock[i-1]+prices[i])    # 第i天持有现金的收益 <= max(第i-1天持有现金, 第i-1天持有股票&第i天卖出)
            stock[i] = max(stock[i-1], cash[i-1]-prices[i])   # 第i天持有股票的收益 <= max(第i-1天持有股票, 第i-1天持有现金&第i天买入)

        return cash[len(prices)-1]
```